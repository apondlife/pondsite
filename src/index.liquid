---
layout: Page.liquid
section: home
title: with pondlife
description: welcome to the pondlife website
---

<article id="pond" class="Pond">
  <div id="pond-body" class="Pond-body">
    <section aria-hidden="true">
      <ul class="Bank" style="--x: 37.4%; --y: 1.2%; --w: 21.9%;">
        <li style="--r: 62%; --a: -9deg;">░░░░░░░░▒░░</li>
        <li style="--l: 26.4%; --t: -0.7%; --a: -6deg;">░░░░░▒▒░░░░░░░░░▓░░░░░</li>
      </ul>

      <ul class="Bank" style="--x: 57.8%; --y: 19%; --a: -15deg;">
        <li>░░</li>
      </ul>

      <ul class="Bank" style="--x: 81.2%; --y: 31.9%; --w: 2.3rem; --a: 9deg;">
        <li>░░</li>
        <li style="--l: 74%; --t: 15%; --a: 21deg;">░</li>
      </ul>

      <ul class="Bank" style="--x: 84.4%; --y: 52.5%; --w: 5rem; --a: -2deg;">
        <li style="--l: 20%; --a: 7deg;">░░</li>
        <li style="--t: 4%; --r: 25%; --a: 3deg;">░░▒░░</li>
        <li style="--l: 70%; --t: 7%; --a: -45deg;">░</li>
      </ul>

      <ul class="Bank" style="--x: 73.5%; --y: 73.2%; --w: 6%;">
        <li style="--r: 30%; --a: -5deg;">▒░</li>
        <li style="--l: 30%; --t: 10%; --a: 5deg;">░░░</li>
      </ul>

      <ul class="Bank" style="--x: 39.1%; --y: 74.5%; --w: 9.3%;">
        <li style="--a: 5deg; --r: 20%;">░░▓░▒▒░░░░░</li>
        <li style="--l: 90%; --t: 10%; --a: -19deg;">░</li>
      </ul>

      <ul class="Bank" style="--x: 31.2%; --y: 81%; --w: 12.5%;">
        <li style="--a: -2deg;">░░░░░░░░▒░░</li>
      </ul>

      <ul class="Bank" style="--x: 17.2%; --y: 86.2%; --w: 9%;">
        <li style="--l: 30%; --a: 3deg;">░░░░░</li>
        <li style="--r: 15%; --t: 7%; --a: 3deg;">░▓░▒▒░░</li>
      </ul>

      <ul class="Bank" style="--x: 4.7%; --y: 48.8%; --w: 11%;">
        <li style="--a: -7deg;">░░░░░░░░░░▒▒</li>
      </ul>

      <ul class="Bank" style="--x: 7.8%; --y: 41%;">
        <li style="--a: -2deg;">░░</li>
      </ul>

      <ul class="Bank" style="--x: 1.6%; --y: 33.3%;">
        <li style="--a: 7deg;">░▒▒░</li>
      </ul>

      <ul class="Bank" style="--x: 7.8%; --y: 21.5%;">
        <li style="--a: -11deg;">░▒▒</li>
      </ul>
    </section>

    <section aria-hidden="true">
      <ul class="Water" style="--x: 15.6%; --y: 10%; --w: 24.8%; --a: -3deg;">
        <li style="--l: 10%; --r: 55%;">░░░░░░░░░░░▒▒▒▒▒▒▒░░░░</li>
        <li style="--l: 0%; --r: 0%;">░░░░░░░░░░░░░░░░▒▒▒▒▒░░░░░░▓░░░</li>
        <li style="--l: 28%; --r: 38%;">░░░░░░░</li>
      </ul>

      <ul class="Water" style="--x: 40.7%; --y: 26.7%; --w: 37.5%; --a: 1deg;">
        <li style="--l: 30%; --r: 2%;">░░░░░░░░░░░░░░░░░░░░░</li>
        <li style="--l: 10%; --r: 19%;">░░░░░░░░░░░▒▒▒▒▒▒▒░░░░</li>
        <li style="--l: 0%; --r: 0%;">░░░░░░░░░░░░░░░░▒▒▒▒▒░░░░░░▓░░░</li>
        <li style="--l: 20%; --r: 57%;">░░░░░░░</li>
      </ul>

      <ul class="Water" style="--x: 25%; --y: 46.2%; --w: 7.2%; --a: -8deg;">
        <li>░░░░░░</li>
      </ul>

      <ul class="Water" style="--x: 40.6%; --y: 56.5%; --w: 42%; --a: -1deg;">
        <li style="--l: 36%; --r: 0%;">░░░░░░░░░▓▓░░░░░░░░░░░░░░░</li>
        <li style="--l: 0%; --r: 14%;">░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░</li>
      </ul>

      <ul class="Water" style="--x: 61%; --y: 70.5%; --w: 4.9%; --a: 3deg;">
        <li>░░░░</li>
      </ul>
    </section>

    <section aria-hidden="true">
      <p class="Lily" style="--x: 26%; --y: 27%;">▖</p>
      <p class="Lily" style="--x: 80%; --y: 43%;">▗</p>
      <p class="Lily" style="--x: 39%; --y: 67%;">▘</p>
      <p class="Lily" style="--x: 19%; --y: 50%;">▝</p>
      <p class="Lily" style="--x: 42%; --y: 44%;">▞</p>
      <p class="Lily" style="--x: 50%; --y: 22%;">▚</p>
    </section>

    <section>
      {% render "life/Life", name: "protozoa", style: "--x: 83%; --y: 13%;" %}
      {% render "life/Life", name: "stentor", style: "--x: 53.9%; --y: 53.8%;" %}
      {% render "life/Life", name: "ameoba", style: "--x: 74.5%; --y: 67%;" %}
      {% render "life/Life", name: "daphnia", href: "/links", style: "--x: 22%; --y: 62%;" %}
    </section>
  </div>
</article>

<script type="module">
  // -- types --
  class Vec2 {
    // -- statics --
    static Temp = [
      new Vec2(),
      new Vec2(),
      new Vec2(),
      new Vec2(),
    ]

    // -- lifetime --
    constructor(x = 0, y = 0) {
      this.x = x
      this.y = y
    }

    // -- operators --
    Zero() {
      this.x = 0
      this.y = 0
      return this
    }

    Temp(tempIndex) {
      return Vec2.Temp[tempIndex].Set(this)
    }

    /**
     * @param {Vec2} other
     **/
    Set(other) {
      this.x = other.x
      this.y = other.y
      return this
    }

    /**
     * @param {Vec2} other
     **/
    Add(other) {
      this.x += other.x
      this.y += other.y
      return this
    }

    /**
     * @param {Vec2} other
     **/
    Sub(other) {
      this.x -= other.x
      this.y -= other.y
      return this
    }

    /**
     * @param {Vec2} other
     **/
    Div(other) {
      this.x /= other.x
      this.y /= other.y
      return this
    }

    /**
     * @param {number} scale
     **/
    Scl(scale) {
      this.x *= scale
      this.y *= scale
      return this
    }

    Normalize() {
      return this.Scl(1 / this.Mag())
    }

    /**
     * @param {Vec2} other
     **/
    Project(other) {
      return this.Scl(this.Dot(other))
    }

    /**
     * @param {number} len
     * @param {number} angle
     **/
    Circular(len, angle) {
      this.x = len * Math.cos(angle),
      this.y = len * Math.sin(angle)
      return this
    }

    // -- queries --
    Mag() {
      return Math.sqrt(this.SqrMag())
    }

    SqrMag() {
      const {x, y} = this
      return x * x + y * y
    }

    /**
     * @param {Vec2} other
     **/
    Dot(other) {
      return this.x * other.x + this.y * other.y
    }

    toString() {
      return `[${Fmt(this.x)}, ${Fmt(this.y)}]`
    }
  }

  class Rng {
    /**
     * @param {number} min
     * @param {number} max
     **/
    constructor(min, max) {
      this.min = min
      this.max = max
    }

    // -- queries --
    Sample() {
      return Lerp(this.min, this.max, Math.random())
    }
  }

  class Sprite {
    constructor(
      /** @type {"block" | "row" | "point"} */
      type
    ) {
      this.type = type
    }
  }

  function Quad() {
    return [
      new Vec2(),
      new Vec2(),
      new Vec2(),
      new Vec2(),
    ]
  }

  class Collider {
    static Temp = Quad()

    constructor(
      /** @type {"life" | "wall"} */
      tag,
      angle = 0,
      quad = Quad()
    ) {
      this.tag = tag
      this.angle = angle
      this.quad = quad
      this.dirty = true
      this.didHit = false
    }
  }

  class Transform {
    constructor(
      pos = new Vec2(),
      width = 0
    ) {
      this.pos = pos
      this.width = width
    }
  }

  class Rigidbody {
    constructor(
      velocity = new Vec2(),
      acceleration = new Vec2()
    ) {
      this.velocity = velocity
      this.acceleration = acceleration
    }
  }

  class Agent {
    constructor(
      duration = 0,
      acceleration = new Vec2()
    ) {
      this.duration = duration
      this.acceleration = acceleration
    }
  }

  class Anim {
    constructor(
      prop = "",
      delta = 0,
      initial = 0,
      duration = 0,
      elapsed = -1
    ) {
      this.prop = prop
      this.delta = delta
      this.initial = initial
      this.duration = duration
      this.elapsed = elapsed >= 0 ? elapsed : Math.random() * duration
    }
  }

  // -- constants --
  const K = {
    FixedDelta: 1000 / 60,
    Deg2Rad: Math.PI / 180,
  }

  const Props = {
    X: "x",
    Y: "y",
  }

  const Css = {
    X: "--x",
    Y: "--y",
    W: "--w",
    L: "--l",
    R: "--r",
    A: "--a",
  }

  const Tuning = {
    Life: {
      Drag: 0.1,
      Perturbation: {
        Pct: 0.001,
        Mag: new Rng(50, 200),
        Rot: new Rng(0, 2 * Math.PI),
        Dur: new Rng(0.1, 0.4),
      },
      InitialVelocity: {
        Mag: new Rng(1, 3),
        Rot: new Rng(0, 2 * Math.PI),
      },
    },
    Water: {
      X: {
        Mag: 2,
        Dur: 8,
      },
    },
    Lily: {
      X: {
        Mag: 1,
        Dur: 10,
      },
      Y: {
        Mag: 1,
        Dur: 10,
      },
    },
  }

  // -- props --
  // the timestamp last frame
  let timePrev = 0

  // the accumulated delta
  let timeRemaining = 0

  // the number of entities
  let numEntities = 0

  // the number of frames to simulate; if < 0 not paused, if >= 0 simulate that many frames while paused.
  let numFrames = -1

  /** @type {HTMLElement} */
  let $pond = null

  /** @type {HTMLElement} */
  let $pondBody = null

  // the size of the pond in pixels
  const pondSize = new Vec2()

  // the size of the pond body in pixels
  const bodySize = new Vec2()

  /** @type {Array<HTMLElement>} */
  const elements = []

  /** @type {Array<Sprite>} */
  const sprites = []

  /** @type {Array<Collider>} */
  const colliders = []

  /** @type {Array<Transform>} */
  const transforms = []

  /** @type {Array<Rigidbody>} */
  const rigidbodies = []

  /** @type {Array<Agent>} */
  const agents = []

  /** @type {Array<Array<Anim>>} */
  const animations = []

  /** @type {Debug} */
  let debug = null

  // -- lifetime --
  function Init() {
    // the debug utilties, if any
    // debug = Debug.Insert()

    // set elements
    $pond = document.getElementById("pond")
    $pondBody = document.getElementById("pond-body")

    // create entities
    const $pondLifes = $pond.getElementsByClassName("Life")
    for (const $pondLife of $pondLifes) {
      CreateLife($pondLife)
    }

    const $pondBanks = $pond.getElementsByClassName("Bank")
    for (const $pondBank of $pondBanks) {
      for (const $child of $pondBank.children) {
        CreateWall($child)
      }
    }

    const $pondWaters = $pond.getElementsByClassName("Water")
    for (const $pondWater of $pondWaters) {
      for (const $child of $pondWater.children) {
        CreateWater($child)
      }
    }

    const $pondLilies = $pond.getElementsByClassName("Lily")
    for (const $pondLily of $pondLilies) {
      CreateLily($pondLily)
    }

    // bind events
    window.addEventListener("resize", OnResize)

    if (debug != null) {
      document.addEventListener("keydown", debug.OnKeyDown)
    }

    // start update loop
    requestAnimationFrame(Update)
  }

  /**
   * @param {HTMLElement} $el
   **/
  function CreateLife($el) {
    const tuning = Tuning.Life

    numEntities += 1

    elements.push($el)

    sprites.push(new Sprite(
      "point"
    ))

    colliders.push(new Collider(
      "life",
      GetStyle_Float(getComputedStyle($el), Css.A) * K.Deg2Rad
    ))

    transforms.push(new Transform(
      new Vec2(
        GetStyle_Float($el.style, Css.X),
        GetStyle_Float($el.style, Css.Y)
      )
    ))

    const v0 = new Vec2().Circular(
      tuning.InitialVelocity.Mag.Sample(),
      tuning.InitialVelocity.Rot.Sample()
    )

    rigidbodies.push(new Rigidbody(v0))

    agents.push(new Agent())

    animations.push(null)
  }

  /**
  * @param {HTMLElement} $el
  **/
  function CreateWall($el) {
    numEntities += 1

    elements.push($el)

    sprites.push(null)

    colliders.push(new Collider(
      "wall",
      GetStyle_Float($el.style, Css.A) * K.Deg2Rad
    ))

    transforms.push(null)

    rigidbodies.push(null)

    agents.push(null)

    animations.push(null)
  }

  /**
   * @param {HTMLElement} $el
   **/
  function CreateWater($el) {
    const tuning = Tuning.Water

    numEntities += 1

    elements.push($el)

    sprites.push(new Sprite(
      "row"
    ))

    colliders.push(null)

    const l = GetStyle_Float($el.style, Css.L)
    const r = GetStyle_Float($el.style, Css.R)

    transforms.push(new Transform(
      new Vec2(l, null),
      100 - r - l,
    ))

    rigidbodies.push(null)

    agents.push(null)

    animations.push([
      new Anim(Props.X, tuning.X.Mag, l, tuning.X.Dur * 1000)
    ])
  }

  /**
   * @param {HTMLElement} $el
   **/
  function CreateLily($el) {
    const tuning = Tuning.Lily

    numEntities += 1

    elements.push($el)

    sprites.push(new Sprite(
      "point"
    ))

    colliders.push(null)

    const x = GetStyle_Float($el.style, Css.X)
    const y = GetStyle_Float($el.style, Css.Y)

    transforms.push(new Transform(
      new Vec2(x, y)
    ))

    rigidbodies.push(null)

    agents.push(null)

    animations.push([
      new Anim(Props.X, tuning.X.Mag, x, tuning.X.Dur * 1000),
      new Anim(Props.Y, tuning.Y.Mag, y, tuning.Y.Dur * 1000),
    ])
  }

  // -- systems --
  /**
   * @param {DOMHighResTimestamp} time
   **/
  function Update(time) {
    // update time
    const delta = time - timePrev
    timeRemaining += delta
    timePrev = time

    // run variable timestep systems
    SyncViewport(delta)

    // run fixed timestep systems
    const fixedDelta = K.FixedDelta
    while (timeRemaining > fixedDelta && numFrames != 0) {
      FixedUpdate(fixedDelta)
      timeRemaining -= fixedDelta
      numFrames -= 1
    }

    // run render systems
    Render(fixedDelta)

    // schedule next frame
    requestAnimationFrame(Update)
  }

  /**
   * @param {number} delta
   **/
  function FixedUpdate(delta) {
    Act(delta)
    SyncQuads(delta)
    Simulate(delta)
    Collide(delta)
    Animate(delta)
  }

  /**
   * @param {number} delta
   **/
  function SyncViewport(delta) {
    const pondRect = $pond.getBoundingClientRect()
    pondSize.x = pondRect.width
    pondSize.y = pondRect.height

    const bodyRect = $pondBody.getBoundingClientRect()
    bodySize.x = bodyRect.width
    bodySize.y = bodyRect.height
  }

  /**
   * @param {number} delta
   **/
  function Act(delta) {
    const tuning = Tuning.Life.Perturbation

    // for every agent
    for (let id = 0; id < numEntities; id++) {
      const a = agents[id]
      const r = rigidbodies[id]
      if (a == null || r == null) {
        continue
      }

      // if this hit something last frame, cancel current acceleration
      const c = colliders[id]
      if (c != null && c.didHit) {
        a.duration = 0
      }

      // if there is an an active acceleration, apply it
      if (a.duration > 0) {
        a.duration = Math.max(a.duration - delta, 0)
        r.acceleration.Add(a.acceleration)
      }
      // otherwise, randomly select a new one
      else if (Math.random() < tuning.Pct) {
        a.duration = tuning.Dur.Sample() * 1000

        a.acceleration.Circular(
          tuning.Mag.Sample(),
          tuning.Rot.Sample()
        )
      }
    }
  }

  /**
   * @param {number} delta
   **/
  function SyncQuads(delta) {
    // for all dirty colliders
    for (let id = 0; id < numEntities; id++) {
      const c = colliders[id]
      if (c == null || !c.dirty) {
        continue
      }

      const $el = elements[id]
      if ($el == null) {
        continue
      }

      // find the unrotated width / height
      const w = $el.offsetWidth
      const w2 = w / 2

      const h = $el.offsetHeight
      const h2 = h / 2

      // find the object center
      let cx = w2
      let cy = h2

      /** @type {HTMLElement} */
      let $tree = $el
      while ($tree != null) {
        cx += $tree.offsetLeft
        cy += $tree.offsetTop

        $tree = $tree.offsetParent
      }

      // rotate the rect to cache the quad
      const aCos = Math.cos(c.angle)
      const aSin = Math.sin(c.angle)

      const xCos = w2 * aCos
      const xSin = w2 * aSin
      const yCos = h2 * aCos
      const ySin = h2 * aSin

      c.quad[0].x = cx + -xCos - -ySin
      c.quad[0].y = cy + -xSin + -yCos

      c.quad[1].x = cx + +xCos - -ySin
      c.quad[1].y = cy + +xSin + -yCos

      c.quad[2].x = cx + +xCos - +ySin
      c.quad[2].y = cy + +xSin + +yCos

      c.quad[3].x = cx + -xCos - +ySin
      c.quad[3].y = cy + -xSin + +yCos

      // flag the quad as synced (unless life)
      c.dirty = c.tag === "life"
    }
  }

  /**
   * @param {number} delta
   **/
  function Simulate(delta) {
    const tuning = Tuning.Life

    // for all colliders
    for (let id = 0; id < numEntities; id++) {
      const c = colliders[id]
      if (c == null) {
        continue
      }

      // if it's not a life, don't simulate
      if (c.tag != "life") {
        continue
      }

      const t = transforms[id]
      const r = rigidbodies[id]
      if (t == null || r == null) {
        continue
      }

      // simulate physics
      const v = r.velocity
      const a = r.acceleration
      const k = delta / 1000

      // calculate drag opposing accelerated velocity
      const va = v.Temp(0).Add(a.Temp(1).Scl(k))
      const vaMag = va.SqrMag()
      const drag = va.Temp(1).Scl(1 / Math.sqrt(vaMag)).Scl(vaMag * tuning.Drag)
      const dvMag = drag.Temp(2).Scl(k).SqrMag()

      // if drag would overcome the final velocity, cancel velocity instead to avoid osscilation
      if (dvMag >= vaMag) {
        a.Zero().Add(v.Temp(2).Scl(-1 / k))
      }
      // otherwise, subtract drag from acceleration
      else {
        a.Sub(drag)
      }

      // resolve forces
      v.Add(a.Temp(1).Scl(k))
      a.Zero()

      // update positions
      t.pos.Add(v.Temp(0).Scl(k))
    }
  }

  /**
   * @param {number} delta
   **/
  function Collide(delta) {
    let didHit = false

    // for all colliders
    for (let id = 0; id < numEntities; id++) {
      const c = colliders[id]
      if (c == null) {
        continue
      }

      // if it's not a life, don't collide
      if (c.tag != "life") {
        continue
      }

      const t = transforms[id]
      if (t == null) {
        continue
      }

      // the rigidbody is optional
      const r = rigidbodies[id]

      // reset collision state
      c.didHit = false

      // for every wall
      for (let iid = 0; iid < numEntities; iid++) {
        const wall = colliders[iid]
        if (wall == null || wall.tag != "wall") {
          continue
        }

        CollideQuad(id, t, c, wall.quad)
      }

      // also collide with screen edge
      const s = pondSize
      CollideQuad(id, t, c, MakeEdge(0, 0, s.x, 0))
      CollideQuad(id, t, c, MakeEdge(s.x, 0, s.x, s.y))
      CollideQuad(id, t, c, MakeEdge(s.x, s.y, 0, s.y))
      CollideQuad(id, t, c, MakeEdge(0, s.y, 0, 0))
    }
  }

  /**
   * @param {number} x0
   * @param {number} y0
   * @param {number} x1
   * @param {number} y1
   **/
  function MakeEdge(x0, y0, x1, y1) {
    const quad = Collider.Temp

    // create the edge
    quad[0].x = x0
    quad[0].y = y0
    quad[1].x = x1
    quad[1].y = y1

    // duplicate the edge on the back two points
    quad[2].x = x0
    quad[2].y = y0
    quad[3].x = x1
    quad[3].y = y1

    return quad
  }

  /**
   * @param {number} id
   * @param {Transform} t
   * @param {Collider} c
   * @param {Vec2[]} b
   **/
  function CollideQuad(id, t, c, b) {
    // check collisions using separating axis theorem; we'll call
    // - a: this quad
    // - b: the quad we're testing against
    const a = c.quad

    // the collision is a hit unless we find a separating axis
    let didHit = true
    let hitPoint = Vec2.Temp[0]
    let hitNormal = Vec2.Temp[1]
    let hitOffset = 0
    let hitOffsetMag = Number.MAX_VALUE

    // for each side of the the other quad
    for (let i0 = 0; i0 < 4 && didHit; i0++) {
      const i1 = (i0 + 1) % 4

      // find the endpoints
      const p0 = b[i0]
      const p1 = b[i1]

      // find the normal
      const bN = Vec2.Temp[2]
      bN.x = p0.y - p1.y
      bN.y = p1.x - p0.x
      bN.Normalize()

      // find the minimum & maximum projection of each quad along the normal
      let aMin = Number.MAX_VALUE
      let aMax = -aMin
      let bMin = aMin
      let bMax = -aMin

      // ...by projecting each point on both quads onto the normal
      for (let j0 = 0; j0 < 4; j0++) {
        const aDotN = bN.Dot(a[j0])
        const bDotN = bN.Dot(b[j0])

        if (aDotN < aMin) {
          aMin = aDotN
        }

        if (aDotN > aMax) {
          aMax = aDotN
        }

        if (bDotN < bMin) {
          bMin = bDotN
        }

        if (bDotN > bMax) {
          bMax = bDotN
        }
      }

      // translate projections w/ the edge of this side (bMax) @ the origin (0)
      aMin -= bMax
      aMax -= bMax
      bMin -= bMax

      // (translate bMax last)
      bMax -= bMax

      // calculate offsets to project out of an overlap
      let lOffset = bMax - aMin
      if (lOffset < 0) {
        lOffset = Number.MAX_VALUE
      }

      let rOffset = bMin - aMax
      if (rOffset > 0) {
        rOffset = Number.MAX_VALUE
      }

      const lOffsetMag = Math.abs(lOffset)
      const rOffsetMag = Math.abs(rOffset)

      // choose the offset that would be the smallest overlap
      let minOffset = lOffset
      let minOffsetMag = lOffsetMag

      if (rOffsetMag < lOffsetMag) {
        minOffset = rOffset
        minOffsetMag = rOffsetMag
      }

      // the max overlap is the sum of the lengths of a and b. if the min offset is less than this, it's an
      // overlap. otherwise, this is a separating axis & it's a miss
      const aLen = aMax - aMin
      const bLen = bMax - bMin
      didHit = minOffsetMag < aLen + bLen

      // if this side hit, find the smallest overlap to project out of the collision
      if (didHit && minOffsetMag < hitOffsetMag) {
        hitNormal.Set(bN)
        hitOffset = minOffset
        hitOffsetMag = minOffsetMag

        // TODO: this is not accurate, only using it for debugging
        hitPoint.Set(p1).Sub(p0).Scl(0.5).Add(p0)
      }
    }

    // if this hit
    if (didHit && hitOffsetMag !== 0) {
      c.didHit = true

      // project out of the collision
      const offset = hitNormal.Temp(3).Scl(hitOffset).Div(bodySize).Scl(100)
      t.pos.Add(offset)

      // if this has physics, cancel the velocity in the normal direction
      const r = rigidbodies[id]
      if (r != null) {
        r.velocity.Sub(hitNormal.Temp(3).Project(r.velocity))
      }

      if (elements[id].className == "Life Stentor") {
        console.log(hitOffset)
      }
    }
  }

  /**
   * @param {number} delta
   **/
  function Animate(delta) {
    // run animations
    for (let id = 0; id < numEntities; id++) {
      // advance animation
      const as = animations[id]
      if (as == null) {
        continue
      }

      for (const a of as) {
        a.elapsed = (a.elapsed + delta) % a.duration

        // make animation symmetric: [0..1] -> [0..1..0]
        let k = a.elapsed / a.duration
        k = (Math.sin(((2 * k) - 0.5) * Math.PI) / 2) + 0.5

        // update position
        const t = transforms[id]
        t.pos[a.prop] = a.initial + a.delta * k
      }
    }
  }

  /**
  * @param {number} delta
  **/
  function Render(delta) {
    for (let id = 0; id < numEntities; id++) {
      const $el = elements[id]
      const s = sprites[id]
      const t = transforms[id]
      if (s == null || t == null) {
        continue
      }

      switch (s.type) {
      case "block":
      case "point":
        SetStyle_Percent($el, Css.X, t.pos.x)
        SetStyle_Percent($el, Css.Y, t.pos.y)
        break

      case "row":
        SetStyle_Percent($el, Css.L, t.pos.x)
        SetStyle_Percent($el, Css.R, 100 - t.width - t.pos.x)
        break
      }
    }

    if (debug != null) {
      debug.Render(delta)
    }
  }

  // -- events --
  function OnResize() {
    for (const c of colliders) {
      if (c != null) {
        c.dirty = true
      }
    }
  }

  // -- queries --
  /**
   * @param {number} min
   * @param {number} max
   * @param {number} t
   **/
  function Lerp(min, max, t) {
    return min + (max - min) * t
  }

  // -- rendering --
  /**
   * @param {CSSStyleDeclaration} styles
   * @param {string} name
   **/
  function GetStyle_Float(styles, name) {
    const value = styles.getPropertyValue(name)
    if (value == null || value === "") {
      return 0
    }

    return Number.parseFloat(value)
  }

  /**
   * @param {number} num
   **/
  function Fmt(num) {
    return num.toFixed(4)
  }

  /**
   * @param {HTMLElement} $el
   * @param {string} name
   * @param {number} value
   **/
  function SetStyle_Percent($el, name, value) {
    $el.style.setProperty(name, `${value}%`)
  }

  // -- debug --
  class Ray {
    constructor() {
      this.src = new Vec2()
      this.dir = new Vec2()
    }
  }

  class Debug {
    constructor() {
      this.$el = document.createElement("canvas")
      /** @type {Array<Ray>} */
      this.rays = []
    }

    static Insert() {
      const debug = new Debug()
      debug.$el.id = "debug"
      debug.$el.classList.toggle("Debug", true)

      document.body.appendChild(debug.$el)

      return debug
    }

    Render() {
      const $body = document.body

      const w = $body.clientWidth
      const h = $body.clientHeight

      this.$el.width = w
      this.$el.height = h

      const ctx = this.$el.getContext("2d")
      ctx.clearRect(0, 0, w, h)

      ctx.strokeStyle = "magenta"
      for (const c of colliders) {
        if (c == null) {
          continue
        }

        ctx.beginPath()

        const p0 = c.quad[0]
        ctx.moveTo(p0.x, p0.y)

        for (let i = 1; i < 4; i++) {
          const pi = c.quad[i]
          ctx.lineTo(pi.x, pi.y)
        }

        ctx.closePath()
        ctx.stroke()
      }

      ctx.fillStyle = "black"
      ctx.strokeStyle = "lime"
      for (const ray of this.rays) {
        const p0 = ray.src
        const p1 = ray.dir.Temp(0).Add(ray.src)

        ctx.beginPath()
        ctx.ellipse(p0.x, p0.y, 2, 2, 0, 0, 2 * Math.PI)
        ctx.fill()

        ctx.beginPath()
        ctx.moveTo(p0.x, p0.y)
        ctx.lineTo(p1.x, p1.y)
        ctx.closePath()
        ctx.stroke()
      }
    }

    /**
     * @param {Vec2} src
     * @param {Vec2} dir
     */
    Draw(src, dir) {
      const ray = new Ray()
      ray.src.Set(src)
      ray.dir.Set(dir)
      debug.rays.push(ray)
    }

    /**
     * @param {KeyboardEvent} evt
     **/
    OnKeyDown(evt) {
      if (evt.key === " ") {
        if (numFrames < 0) {
          numFrames = 0
        } else {
          numFrames = 1
        }
      }
    }
  }

  // -- bootstrap --
  Init()
</script>