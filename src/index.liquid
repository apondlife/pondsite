---
layout: Page.liquid
section: home
title: with pondlife
description: welcome to the pondlife website
---

<article id="pond" class="Pond">
  <div class="Pond-body">
    <section aria-hidden="true">
      <ul class="Bank" style="--x: 37.4%; --y: 1.2%; --w: 21.9%;">
        <li style="--r: 62%; --a: -9deg;">░░░░░░░░▒░░</li>
        <li style="--l: 26.4%; --t: -0.7%; --a: -6deg;">░░░░░▒▒░░░░░░░░░▓░░░░░</li>
      </ul>

      <ul class="Bank" style="--x: 57.8%; --y: 19%; --a: -15deg;">
        <li>░░</li>
      </ul>

      <ul class="Bank" style="--x: 81.2%; --y: 31.9%; --w: 2.3rem; --a: 9deg;">
        <li>░░</li>
        <li style="--l: 74%; --t: 15%; --a: 21deg;">░</li>
      </ul>

      <ul class="Bank" style="--x: 84.4%; --y: 52.5%; --w: 5rem; --a: -2deg;">
        <li style="--l: 20%; --a: 7deg;">░░</li>
        <li style="--t: 4%; --r: 25%; --a: 3deg;">░░▒░░</li>
        <li style="--l: 70%; --t: 7%; --a: -45deg;">░</li>
      </ul>

      <ul class="Bank" style="--x: 73.5%; --y: 73.2%; --w: 6%;">
        <li style="--r: 30%; --a: -5deg;">▒░</li>
        <li style="--l: 30%; --t: 10%; --a: 5deg;">░░░</li>
      </ul>

      <ul class="Bank" style="--x: 39.1%; --y: 74.5%; --w: 9.3%;">
        <li style="--a: 5deg; --r: 20%;">░░▓░▒▒░░░░░</li>
        <li style="--l: 90%; --t: 10%; --a: -19deg;">░</li>
      </ul>

      <ul class="Bank" style="--x: 31.2%; --y: 81%; --w: 12.5%;">
        <li style="--a: -2deg;">░░░░░░░░▒░░</li>
      </ul>

      <ul class="Bank" style="--x: 17.2%; --y: 86.2%; --w: 9%;">
        <li style="--l: 30%; --a: 3deg;">░░░░░</li>
        <li style="--r: 15%; --t: 7%; --a: 3deg;">░▓░▒▒░░</li>
      </ul>

      <ul class="Bank" style="--x: 4.7%; --y: 48.8%; --w: 11%;">
        <li style="--a: -7deg;">░░░░░░░░░░▒▒</li>
      </ul>

      <ul class="Bank" style="--x: 7.8%; --y: 41%;">
        <li style="--a: -2deg;">░░</li>
      </ul>

      <ul class="Bank" style="--x: 1.6%; --y: 33.3%;">
        <li style="--a: 7deg;">░▒▒░</li>
      </ul>

      <ul class="Bank" style="--x: 7.8%; --y: 21.5%;">
        <li style="--a: -11deg;">░▒▒</li>
      </ul>
    </section>

    <section aria-hidden="true">
      <ul class="Water" style="--x: 15.6%; --y: 10%; --w: 24.8%; --a: -3deg;">
        <li style="--l: 10%; --r: 55%;">░░░░░░░░░░░▒▒▒▒▒▒▒░░░░</li>
        <li style="--l: 0%; --r: 0%;">░░░░░░░░░░░░░░░░▒▒▒▒▒░░░░░░▓░░░</li>
        <li style="--l: 28%; --r: 38%;">░░░░░░░</li>
      </ul>

      <ul class="Water" style="--x: 40.7%; --y: 26.7%; --w: 37.5%; --a: 1deg;">
        <li style="--l: 30%; --r: 2%;">░░░░░░░░░░░░░░░░░░░░░</li>
        <li style="--l: 10%; --r: 19%;">░░░░░░░░░░░▒▒▒▒▒▒▒░░░░</li>
        <li style="--l: 0%; --r: 0%;">░░░░░░░░░░░░░░░░▒▒▒▒▒░░░░░░▓░░░</li>
        <li style="--l: 20%; --r: 57%;">░░░░░░░</li>
      </ul>

      <ul class="Water" style="--x: 25%; --y: 46.2%; --w: 7.2%; --a: -8deg;">
        <li>░░░░░░</li>
      </ul>

      <ul class="Water" style="--x: 40.6%; --y: 56.5%; --w: 42%; --a: -1deg;">
        <li style="--l: 36%; --r: 0%;">░░░░░░░░░▓▓░░░░░░░░░░░░░░░</li>
        <li style="--l: 0%; --r: 14%;">░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░</li>
      </ul>

      <ul class="Water" style="--x: 61%; --y: 70.5%; --w: 4.9%; --a: 3deg;">
        <li>░░░░</li>
      </ul>
    </section>

    <section aria-hidden="true">
      <p class="Lily" style="--x: 26%; --y: 27%;">▖</p>
      <p class="Lily" style="--x: 80%; --y: 43%;">▗</p>
      <p class="Lily" style="--x: 39%; --y: 67%;">▘</p>
      <p class="Lily" style="--x: 19%; --y: 50%;">▝</p>
      <p class="Lily" style="--x: 42%; --y: 44%;">▞</p>
      <p class="Lily" style="--x: 50%; --y: 22%;">▚</p>
    </section>

    <section>
      {% render "life/Life", name: "protozoa", style: "--x: 83%; --y: 13%;" %}
      {% render "life/Life", name: "stentor", style: "--x: 53.9%; --y: 53.8%;" %}
      {% render "life/Life", name: "ameoba", style: "--x: 74.5%; --y: 67%;" %}
      {% render "life/Life", name: "daphnia", href: "/links", style: "--x: 22%; --y: 62%;" %}
    </section>
  </div>
</article>

<script type="module">
  // -- types --
  class Vec2 {
    // -- statics --
    static Temp1 = new Vec2()
    static Temp2 = new Vec2()
    static Temp3 = new Vec2()

    // -- lifetime --
    constructor(x = 0, y = 0) {
      this.x = x
      this.y = y
    }

    // -- operators --
    Zero() {
      this.x = 0
      this.y = 0
      return this
    }

    Temp(temp = Vec2.Temp1) {
      return temp.Set(this)
    }

    /**
     * @param {Vec2} other
     **/
    Set(other) {
      this.x = other.x
      this.y = other.y
      return this
    }

    /**
     * @param {Vec2} other
     **/
    Add(other) {
      this.x += other.x
      this.y += other.y
      return this
    }

    /**
     * @param {Vec2} other
     **/
    Sub(other) {
      this.x -= other.x
      this.y -= other.y
      return this
    }

    /**
     * @param {number} scale
     **/
    Mul(scale) {
      this.x *= scale
      this.y *= scale
      return this
    }

    Normalize() {
      return this.Mul(1 / this.Mag())
    }

    /**
     * @param {number} len
     * @param {number} angle
     **/
    Circular(len, angle) {
      this.x = len * Math.cos(angle),
      this.y = len * Math.sin(angle)
      return this
    }

    // -- queries --
    Mag() {
      const {x, y} = this
      return Math.sqrt(x * x + y * y)
    }

    /**
     * @param {Vec2} other
     **/
    Dot(other) {
      return this.x * other.x + this.y * other.y
    }

    toString() {
      return `[${fmt(this.x)}, ${fmt(this.y)}]`
    }
  }

  class Sprite {
    constructor(
      /** @type {"block" | "row" | "point"} */
      type
    ) {
      this.type = type
    }
  }

  class Collider {
    constructor(
      /** @type {"life" | "wall"} */
      tag,
      angle = 0,
      quad = [new Vec2(), new Vec2(), new Vec2(), new Vec2()]
    ) {
      this.tag = tag
      this.angle = angle
      this.quad = quad
      this.dirty = true
    }
  }

  class Transform {
    constructor(
      pos = new Vec2(),
      width = 0
    ) {
      this.pos = pos
      this.width = width
    }
  }

  class Rigidbody {
    constructor(
      velocity = new Vec2(),
      acceleration = new Vec2()
    ) {
      this.velocity = velocity
      this.acceleration = acceleration
    }
  }

  class Agent {
    constructor(
      duration = 0,
      acceleration = new Vec2()
    ) {
      this.duration = duration
      this.acceleration = acceleration
    }
  }

  class Anim {
    constructor(
      prop = "",
      delta = 0,
      initial = 0,
      duration = 0,
      elapsed = -1
    ) {
      this.prop = prop
      this.delta = delta
      this.initial = initial
      this.duration = duration
      this.elapsed = elapsed >= 0 ? elapsed : Math.random() * duration
    }
  }

  // -- constants --
  const K = {
    FixedDelta: 1000 / 60,
    Deg2Rad: Math.PI / 180,
  }

  const Props = {
    X: "x",
    Y: "y",
  }

  const Css = {
    X: "--x",
    Y: "--y",
    W: "--w",
    L: "--l",
    R: "--r",
    A: "--a",
  }

  // -- props --
  // the timestamp last frame
  let timePrev = 0

  // the accumulated delta
  let timeRemaining = 0

  // the number of entities
  let numEntities = 0

  // the number of frames to simulate; if < 0 not paused, if >= 0 simulate that many frames while paused.
  let numFrames = -1

  /** @type {Array<HTMLElement>} */
  const elements = []

  /** @type {Array<Sprite>} */
  const sprites = []

  /** @type {Array<Collider>} */
  const colliders = []

  /** @type {Array<Transform>} */
  const transforms = []

  /** @type {Array<Rigidbody>} */
  const rigidbodies = []

  /** @type {Array<Agent>} */
  const agents = []

  /** @type {Array<Array<Anim>>} */
  const animations = []

  // -- lifetime --
  function Init() {
    const $pond = document.getElementById("pond")

    // create entities
    const $pondLifes = $pond.getElementsByClassName("Life")
    for (const $pondLife of $pondLifes) {
      CreateLife($pondLife)
    }

    const $pondBanks = $pond.getElementsByClassName("Bank")
    for (const $pondBank of $pondBanks) {
      for (const $child of $pondBank.children) {
        CreateWall($child)
      }
    }

    const $pondWaters = $pond.getElementsByClassName("Water")
    for (const $pondWater of $pondWaters) {
      for (const $child of $pondWater.children) {
        CreateWater($child)
      }
    }

    const $pondLilies = $pond.getElementsByClassName("Lily")
    for (const $pondLily of $pondLilies) {
      CreateLily($pondLily)
    }

    // bind events
    if (debug != null) {
      document.addEventListener("keydown", debug.OnKeyDown)
    }

    // start update loop
    requestAnimationFrame(Update)
  }

  /**
   * @param {HTMLElement} $el
   **/
  function CreateLife($el) {
    numEntities += 1

    elements.push($el)

    sprites.push(new Sprite(
      "point"
    ))

    colliders.push(new Collider(
      "life",
      GetStyle_Float(getComputedStyle($el), Css.A) * K.Deg2Rad
    ))

    transforms.push(new Transform(
      new Vec2(
        GetStyle_Float($el.style, Css.X),
        GetStyle_Float($el.style, Css.Y)
      )
    ))

    const mag = Lerp(1, 3, Math.random())
    const rot = Math.random() * 2 * Math.PI
    // const vel = new Vec2(-10, 50)
    // const vel = new Vec2(0, 70)
    const vel = new Vec2().Circular(mag, rot)

    rigidbodies.push(new Rigidbody(vel))

    agents.push(new Agent())

    animations.push(null)
  }

  /**
  * @param {HTMLElement} $el
  **/
  function CreateWall($el) {
    numEntities += 1

    elements.push($el)

    sprites.push(null)

    colliders.push(new Collider(
      "wall",
      GetStyle_Float($el.style, Css.A) * K.Deg2Rad
    ))

    transforms.push(null)

    rigidbodies.push(null)

    agents.push(null)

    animations.push(null)
  }

  /**
   * @param {HTMLElement} $el
   **/
  function CreateWater($el) {
    numEntities += 1

    elements.push($el)

    sprites.push(new Sprite(
      "row"
    ))

    colliders.push(null)

    const l = GetStyle_Float($el.style, Css.L)
    const r = GetStyle_Float($el.style, Css.R)

    transforms.push(new Transform(
      new Vec2(l, null),
      100 - r - l,
    ))

    rigidbodies.push(null)

    agents.push(null)

    animations.push([
      new Anim(Props.X, 2, l, 8 * 1000)
    ])
  }

  /**
   * @param {HTMLElement} $el
   **/
  function CreateLily($el) {
    numEntities += 1

    elements.push($el)

    sprites.push(new Sprite(
      "point"
    ))

    colliders.push(null)

    const x = GetStyle_Float($el.style, Css.X)
    const y = GetStyle_Float($el.style, Css.Y)

    transforms.push(new Transform(
      new Vec2(x, y)
    ))

    rigidbodies.push(null)

    agents.push(null)

    animations.push([
      new Anim(Props.X, 1, x, 10 * 1000),
      new Anim(Props.Y, 1, y, 10 * 1000)
    ])
  }

  // -- systems --
  /**
   * @param {DOMHighResTimestamp} time
   **/
  function Update(time) {
    // update time
    timeRemaining += time - timePrev
    timePrev = time

    // run fixed timestep systems
    const delta = K.FixedDelta
    while (timeRemaining > delta && numFrames != 0) {
      FixedUpdate(delta)
      timeRemaining -= delta
      numFrames -= 1
    }

    // run render systems
    Render(delta)

    // schedule next frame
    requestAnimationFrame(Update)
  }

  function FixedUpdate(delta) {
    Act(delta)
    SyncQuads(delta)
    Simulate(delta)
    Animate(delta)
  }

  /**
   * @param {delta} number
   **/
  function Act(delta) {
    // for every agents
    for (let id = 0; id < numEntities; id++) {
      const a = agents[id]
      const r = rigidbodies[id]
      if (a == null || r == null) {
        continue
      }

      // if there is an an active acceleration, apply it
      if (a.duration > 0) {
        a.duration = Math.max(a.duration - delta, 0)
        r.acceleration.Add(a.acceleration)
      }
      // otherwise, randomly select a new one
      else if (Math.random(0.2)) {
        a.duration = Lerp(100, 300, Math.random())

        const mag = Lerp(100, 200, Math.random())
        const rot = Math.random() * 2 * Math.PI
        a.acceleration.Circular(mag, rot)
      }
    }
  }

  /**
   * @param {delta} number
   **/
  function SyncQuads(delta) {
    // for all dirty colliders
    for (let id = 0; id < numEntities; id++) {
      const c = colliders[id]
      if (c == null || !c.dirty) {
        continue
      }

      const $el = elements[id]
      if ($el == null) {
        continue
      }

      // find the unrotated width / height
      const w = $el.offsetWidth
      const w2 = w / 2

      const h = $el.offsetHeight
      const h2 = h / 2

      // find the object center
      let cx = w2
      let cy = h2

      /** @type {HTMLElement} */
      let $tree = $el
      while ($tree != null) {
        cx += $tree.offsetLeft
        cy += $tree.offsetTop

        $tree = $tree.offsetParent
      }

      // rotate the rect to cache the quad
      const aCos = Math.cos(c.angle)
      const aSin = Math.sin(c.angle)

      const xCos = w2 * aCos
      const xSin = w2 * aSin
      const yCos = h2 * aCos
      const ySin = h2 * aSin

      c.quad[0].x = cx + -xCos - -ySin
      c.quad[0].y = cy + -xSin + -yCos

      c.quad[1].x = cx + +xCos - -ySin
      c.quad[1].y = cy + +xSin + -yCos

      c.quad[2].x = cx + +xCos - +ySin
      c.quad[2].y = cy + +xSin + +yCos

      c.quad[3].x = cx + -xCos - +ySin
      c.quad[3].y = cy + -xSin + +yCos

      // flag the quad as synced (unless life)
      c.dirty = c.tag === "life"
    }
  }

  /**
   * @param {delta} number
   **/
  function Simulate(delta) {
    // for all colliders
    for (let id = 0; id < numEntities; id++) {
      const c = colliders[id]
      if (c == null) {
        continue
      }

      // if it's not a life, don't simulate
      if (c.tag != "life") {
        continue
      }

      const t = transforms[id]
      const r = rigidbodies[id]
      if (t == null || r == null) {
        continue
      }

      // simulate physics
      const v = r.velocity
      const a = r.acceleration
      const k = delta / 1000

      // resolve forces
      v.Add(a.Temp().Mul(k))
      a.Zero()

      // update positions
      t.pos.Add(v.Temp().Mul(k))

      // bounce off walls
      for (let iid = 0; iid < numEntities; iid++) {
        const wall = colliders[iid]
        if (wall == null || wall.tag != "wall") {
          continue
        }

        // check collisions using separating axis theroem; we'll call
        // - a: this quad
        // - b: the quad we're testing against
        const a = c.quad
        const b = wall.quad

        // the collision is a hit unless we find a separating axis
        let didHit = true
        let hitPoint = Vec2.Temp1
        let hitNormal = Vec2.Temp2
        let hitOffset = 0
        let hitOffsetMag = Number.MAX_VALUE

        // for each side of the this quad
        for (let i0 = 0; i0 < 4 && didHit; i0++) {
          const i1 = (i0 + 1) % 4

          // find the endpoints
          const p0 = a[i0]
          const p1 = a[i1]

          // find the normal
          const n = Vec2.Temp3
          n.x = p0.y - p1.y
          n.y = p1.x - p0.x
          n.Normalize()

          // find the minimum & maximum projection of each quad along the normal
          let aMin = Number.MAX_VALUE
          let aMax = -aMin
          let bMin = aMin
          let bMax = -aMin

          let projA = []
          let projB = []

          // ...by projecting each point on both quads onto the normal
          for (let j0 = 0; j0 < 4; j0++) {
            const aDotN = n.Dot(a[j0])
            const bDotN = n.Dot(b[j0])

            projA.push(aDotN)
            projB.push(bDotN)

            if (aDotN < aMin) {
              aMin = aDotN
            }

            if (aDotN > aMax) {
              aMax = aDotN
            }

            if (bDotN < bMin) {
              bMin = bDotN
            }

            if (bDotN > bMax) {
              bMax = bDotN
            }
          }

          let mins = [aMin, aMax, bMin, bMax]

          // translate projections w/ the edge of this side (aMax) @ the origin (0)
          aMin -= aMax
          bMin -= aMax
          bMax -= aMax

          // (translate aMax last)
          aMax -= aMax

          // calculate offsets to project out of an overlap
          let lOffset = bMax - aMin
          if (lOffset < 0) {
            lOffset = Number.MAX_VALUE
          }

          let rOffset = aMax - bMin
          if (rOffset > 0) {
            rOffset = Number.MAX_VALUE
          }

          const lOffsetMag = Math.abs(lOffset)
          const rOffsetMag = Math.abs(rOffset)

          // choose the offset that would be the smallest overlap
          let minOffset = lOffset
          let minOffsetMag = lOffsetMag

          if (rOffsetMag < lOffsetMag) {
            minOffset = rOffset
            minOffsetMag = rOffsetMag
          }

          // the max overlap is the sum of the lengths of a and b. if the min offset is less than this, it's an
          // overlap. otherwise, this is a separating axis & it's a miss
          const aLen = aMax - aMin
          const bLen = bMax - bMin
          didHit = minOffsetMag < aLen + bLen

          // if it hit, find the smallest overlap to project out of the collision
          if (didHit && minOffsetMag < hitOffsetMag) {
            hitPoint.Set(p1).Sub(p0).Mul(0.5).Add(p0)
            hitNormal.Set(n)
            hitOffset = minOffset
            hitOffsetMag = minOffsetMag
          }

          if (elements[id].className === "Life Daphnia" && elements[iid].id === "test") {
            console.log(`
              side - ${i0} n: ${n} n•up: ${fmt(n.Dot(new Vec2(0, -1)))}
              projA - ${projA.map(fmt)}
              projB - ${projB.map(fmt)}
              bound - ${mins.map(fmt)}
              a - min ${fmt(aMin)} max ${fmt(aMax)}
              b - min ${fmt(bMin)} max ${fmt(bMax)}
              offsets - l: ${fmt(lOffset)} r: ${fmt(rOffset)}
              hit - ?: ${didHit} p: ${hitPoint} n: ${hitNormal} o: ${hitOffset}
            `)
          }
        }

        if (didHit) {
          const $aEl = elements[id]
          const $bEl = elements[iid]

          debug.Draw(hitPoint, hitNormal.Mul(hitOffset))

          $aEl.classList.toggle("is-hit", true)
          $bEl.classList.toggle("is-hit", true)

          numFrames = 1
        }
      }
    }
  }

  function fmt(num) {
    return num.toFixed(4)
  }

  /**
   * @param {number} delta
   **/
  function Animate(delta) {
    // run animations
    for (let id = 0; id < numEntities; id++) {
      // advance animation
      const as = animations[id]
      if (as == null) {
        continue
      }

      for (const a of as) {
        a.elapsed = (a.elapsed + delta) % a.duration

        // make animation symmetric: [0..1] -> [0..1..0]
        let k = a.elapsed / a.duration
        k = (Math.sin(((2 * k) - 0.5) * Math.PI) / 2) + 0.5

        // update position
        const t = transforms[id]
        t.pos[a.prop] = a.initial + a.delta * k
      }
    }
  }

  /**
  * @param {number} delta
  **/
  function Render(delta) {
    for (let id = 0; id < numEntities; id++) {
      const $el = elements[id]
      const s = sprites[id]
      const t = transforms[id]
      if (s == null || t == null) {
        continue
      }

      switch (s.type) {
      case "block":
      case "point":
        SetStyle_Percent($el, Css.X, t.pos.x)
        SetStyle_Percent($el, Css.Y, t.pos.y)
        break

      case "row":
        SetStyle_Percent($el, Css.L, t.pos.x)
        SetStyle_Percent($el, Css.R, 100 - t.width - t.pos.x)
        break
      }
    }

    if (debug != null) {
      debug.Render(delta)
    }
  }

  // -- queries --
  /**
   * @param {number} min
   * @param {number} max
   * @param {number} t
   **/
  function Lerp(min, max, t) {
    return min + (max - min) * t
  }

  // -- rendering --
  /**
   * @param {CSSStyleDeclaration} styles
   * @param {string} name
   **/
  function GetStyle_Float(styles, name) {
    const value = styles.getPropertyValue(name)
    if (value == null || value === "") {
      return 0
    }

    return Number.parseFloat(value)
  }

  /**
   * @param {HTMLElement} $el
   * @param {string} name
   * @param {number} value
   **/
  function SetStyle_Percent($el, name, value) {
    $el.style.setProperty(name, `${value}%`)
  }

  // -- debug --
  class Ray {
    constructor() {
      this.src = new Vec2()
      this.dir = new Vec2()
    }
  }

  class Debug {
    constructor() {
      this.$el = document.createElement("canvas")
      /** @type {Array<Ray>} */
      this.rays = []
    }

    static Insert() {
      const debug = new Debug()
      debug.$el.id = "debug"
      debug.$el.classList.toggle("Debug", true)

      document.body.appendChild(debug.$el)

      return debug
    }

    Render() {
      const $body = document.body

      const w = $body.clientWidth
      const h = $body.clientHeight

      this.$el.width = w
      this.$el.height = h

      const ctx = this.$el.getContext("2d")
      ctx.clearRect(0, 0, w, h)

      ctx.strokeStyle = "magenta"
      for (const c of colliders) {
        if (c == null) {
          continue
        }

        ctx.beginPath()

        const p0 = c.quad[0]
        ctx.moveTo(p0.x, p0.y)

        for (let i = 1; i < 4; i++) {
          const pi = c.quad[i]
          ctx.lineTo(pi.x, pi.y)
        }

        ctx.closePath()
        ctx.stroke()
      }

      ctx.fillStyle = "black"
      ctx.strokeStyle = "lime"
      for (const ray of this.rays) {
        const p0 = ray.src
        const p1 = ray.dir.Temp().Add(ray.src)

        ctx.beginPath()
        ctx.ellipse(p0.x, p0.y, 2, 2, 0, 0, 2 * Math.PI)
        ctx.fill()

        ctx.beginPath()
        ctx.moveTo(p0.x, p0.y)
        ctx.lineTo(p1.x, p1.y)
        ctx.closePath()
        ctx.stroke()
      }
    }

    /**
     * @param {Vec2} src
     * @param {Vec2} dir
     */
    Draw(src, dir) {
      const ray = new Ray()
      ray.src.Set(src)
      ray.dir.Set(dir)
      debug.rays.push(ray)
    }

    /**
     * @param {KeyboardEvent} evt
     **/
    OnKeyDown(evt) {
      if (evt.key === " ") {
        numFrames = numFrames != 0 ? -1 : 1
      }
    }
  }

  // the debug utilties, if any
  let debug = Debug.Insert()

  // -- bootstrap --
  Init()
</script>